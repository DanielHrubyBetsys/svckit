# coding: utf-8

require 'minus5_mssql'
require 'hashie'
require 'json'
require 'pp'
require 'csv'
require 'erb'

desc "regenerate sprotovi.json u assets"
task :assets do
  build_sportovi
  `cd ../../pkg/tecajna; go-bindata -pkg=tecajna assets`
  build_betgenius_connector_razrade
  `cd ../../pkg/betgenius; go-bindata -pkg=betgenius assets`
  build_betradar_connector_razrade
  `cd ../../pkg/betradar/export; go-bindata -pkg=export assets`
  build_vsport_razrade
  `cd ../../pkg/vsport/model; go-bindata -pkg=model assets`
  build_nazivi
end

task :panel do
  build_panel
end

desc "generate keys.go, keys.json"
task :keys do
  fs, sf = read_keys
  js_generate_keys sf
  go_generate_keys "tecajna", "../../pkg/tecajna/keys_gen.go", fs
  go_generate_keys "model", "../../pkg/vsport/model/keys_gen.go", fs

  ## ovako sam zamjenio inline stringove s konstantama, korisno
  # fs.each do |k, v| 
  #   key = "key#{k[0].upcase}#{k[1..-1]}"
  #   cmd = "sed -i '' -e s/\\\"#{k}\\\"/#{key}/g export.go  "
  #   `#{cmd}`
  #   print "#{cmd}\n"
  # end
end

def read_keys
  fs = {} #full -> short
  sf = {} #short -> full 
  File.read("keys.txt").each_line do |l|
    p = l.split(" ")
    next if p.size != 2
    full = p[0]
    short = p[1]
    fs[full] = short
    if sf[short]
      print "short: #{short}, full: #{full} !!! #{short} je vec zauzet s: #{sf[short]}\n"
      exit 1
    end
    sf[short] = full
  end
  return [fs, sf]
end

def js_generate_keys(fs)
  file = "#{ENV['HOME']}/work/web/src/js/src/service/live_ponuda.service/src/legenda.js"
  File.open(file, "w+") do |f|
    f.puts "define([], function(){"
    f.puts "return #{JSON.pretty_generate(fs)};"
    f.puts "});"
  end
  print "generiran #{file}\n"
end

def go_generate_keys(pkg, file, fs)
  go_template = <<-go_t
//ovaj file je generiran komandom
//  rake keys
package <%= pkg %>

const (<%fs.each do |k, v|%>
    key<%=k[0].upcase%><%=k[1..-1]%>="<%=v%>" <%end%>
)
  go_t
  code = ERB.new(go_template).result(OpenStruct.new(fs).instance_eval { binding })
  File.open(file, "w+") do |f|
    f.puts code
  end
  print "generiran #{file}\n"
  `go fmt #{file}`
end

#parametri db konekcije, ove env varijable tebaju biti definirane
@conn = {
  username: ENV["ALFA_USER"],
  password: ENV["ALFA_PWD"],
  host:     "5-db-principal.supersport.local",
  database: "SuperSport"
}

#citaj sql iz file-a, ili vrati inline
def sql(fn, p1)
  #pazi
  #nazivi kolona su uvijek malim slovima to radi najmanje problema kada ucitavamo iz file-a
  #camel case je ok, ali ruby stil s _ nije
  if fn == :komb
    #TODO - ovdje sam ostavio dependency na betradar_live schemu
    "select grupa from betradar_live.razrade_kombiniranja where sport_razrada_id = #{p1}"
  elsif fn == :razrade
    <<-sql
    select
      id,
      poredak,
      live_id liveId,
      betradar_id betradarId,
      betgenius_id betgeniusId,
      sport_panel sportPanel,
      panel_template panelTemplate,
      coalesce(template, naziv) naziv,
      plazma_template plazmaTemplate,
      blagajna_template blagajnaTemplate,
      podbroj,
      stopirano,
      ostalo,
      tecajevi_prijevod prijevod,
      cast(akceleracija as float) intervalUlogLimit
    from tecajna.razrade
    where sport_id = #{p1} --and live_id is not null 
    order by 2
    sql
  elsif fn == :panel
    <<-sql
    select
      panel_id panelId,
      naziv,
      tecajevi
    from tecajna.panel
    where sport_id = #{p1}
    order by 1
    sql
  elsif fn == :sportovi
    "select id, naziv, poredak, live_id liveid from tecajna.sportovi"
    #File.read "#{File.dirname(__FILE__)}/sql/#{fn.to_s}.sql"
  elsif fn == :razrade_bgc  #razade za betgenius_connector (samo IDjevi)
    <<-sql2
    select id, betgenius_id
    from tecajna.razrade 
    where betgenius_id is not null
    order by sport_id, poredak
    sql2
  elsif fn == :razrade_brm  #razade za betradar_merger (samo IDjevi)
    <<-sql2
    select id, betradar_id, sport_id, tenis
    from tecajna.razrade 
    where betradar_id is not null
    and betradar_id != ''
    order by sport_id, poredak
    sql2
  elsif fn == :razrade_vsport #razrade za vsport (uzimamo nogomet, kosarku i tenis)
    <<-sql2
    select id, naziv, osnovni_naziv, ignore_vsport
    from tecajna.razrade
    where betradar_id is not null
    and betradar_id != ''
    and sport_id in (2, 4, 5)
    sql2
  elsif fn == :nazivi
    <<-sql2
    select m.id ID, m.description Name, t1.id HomeId, t1.name HomeName, t2.id AwayId, t2.name AwayName, l.id LeagueId, l.name LeagueName, m.schedule StartTime
    from dbo.matches as m with (nolock)
    inner join dbo.matchteams as t1 with (nolock)
    on m.homeid = t1.id
    inner join dbo.matchteams as t2 with (nolock)
    on m.guestid = t2.id
    inner join dbo.leagues as l with (nolock)
    on m.leagueid = l.id
    where schedule > current_timestamp
    and m.id = m.baseid
    and m.id > 0
    sql2
  end

end

def build_nazivi
  @reader = Minus5::Mssql::Adapter.new(@conn)
  r = @reader.select sql(:nazivi, 0)
  File.open("../../../../../../../tmp/nazivi.json", "w+") do |f|
    f.puts JSON.pretty_generate(r)
  end
end

def build_betgenius_connector_razrade
  @reader = Minus5::Mssql::Adapter.new(@conn)
  r = @reader.select sql(:razrade_bgc, 0)
  File.open("../../pkg/betgenius/assets/razrade.json", "w+") do |f|
    f.puts JSON.pretty_generate(r)
  end
end

def build_betradar_connector_razrade
  @reader = Minus5::Mssql::Adapter.new(@conn)
  r = @reader.select sql(:razrade_brm, 0)
  r = r.map{ |s| Hashie::Mash.new s }
  r.each do |razrada|
    razrada.tenis = razrada.tenis == 1
  end
  File.open("../../pkg/betradar/export/assets/razrade.json", "w+") do |f|
    f.puts JSON.pretty_generate(r)
  end
end

def build_vsport_razrade
  @reader = Minus5::Mssql::Adapter.new(@conn)
  r = @reader.select sql(:razrade_vsport, 0)
  File.open("../../pkg/vsport/model/assets/razrade.json", "w+") do |f|
    f.puts JSON.pretty_generate(r)
  end
end

def build_sportovi
  @reader = Minus5::Mssql::Adapter.new(@conn)
  sportovi = @reader.select sql(:sportovi, 0)
  sportovi = sportovi.map{ |s| Hashie::Mash.new s }
  sportovi.each do |sport|
    sport.razrade = @reader.select sql(:razrade, sport.id)
    sport.razrade.each do |r|
      r.stopirano = r.stopirano == 1
      r.ostalo = r.ostalo == 1
      r.prijevod = r.prijevod == 1
      if r.liveId
        komb = @reader.select sql(:komb, r.liveId)
        rg = []
        komb.each do |k|
          rg << k[:grupa]
        end
        if rg.size > 0
          r.kombiniranjegrupe = rg  #sva mala slova, namjerno
        end
      end
    end
  end

  File.open("../../pkg/tecajna/assets/sportovi.json", "w+") do |f|
    f.puts JSON.pretty_generate(sportovi)
  end
end

def build_panel
  @reader = Minus5::Mssql::Adapter.new(@conn)
  sportovi = @reader.select sql(:sportovi, 0)
  sportovi = sportovi.map{ |s| Hashie::Mash.new s }
  sportovi.each do |sport|
    sport.panel = @reader.select sql(:panel, sport.id)
  end
  File.open("../../pkg/tecajna/panel.json", "w+") do |f|
    f.puts JSON.pretty_generate(sportovi)
  end
end
