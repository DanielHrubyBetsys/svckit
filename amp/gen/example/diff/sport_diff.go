// Code generated by go generate; DO NOT EDIT.
package diff

import "sync"

type BookDiff struct {
	Version *int                  `json:"version,omitempty" bson:"version,omitempty" msg:"version"`
	Sports  map[string]*SportDiff `json:"sports,omitempty" bson:"sports,omitempty" msg:"sports"`
	Events  map[string]*EventDiff `json:"events,omitempty" bson:"events,omitempty" msg:"events"`
	Items   map[string]*ItemDiff  `json:"events,omitempty" bson:"events,omitempty" msg:"events"`
}

func (o BookDiff) empty() bool {
	return o.Version == nil &&
		(o.Sports == nil || len(o.Sports) == 0) &&
		(o.Events == nil || len(o.Events) == 0) &&
		(o.Items == nil || len(o.Items) == 0)
}

type SportDiff struct {
	Name       *string                  `json:"name,omitempty" bson:"name,omitempty" msg:"name"`
	Order      *int                     `json:",omitempty" bson:",omitempty" msg:""`
	Categories map[string]*CategoryDiff `json:"categories,omitempty" bson:"categories,omitempty" msg:"categories"`
}

func (o SportDiff) empty() bool {
	return o.Name == nil &&
		o.Order == nil &&
		(o.Categories == nil || len(o.Categories) == 0)
}

type CategoryDiff struct {
	Name  *string `json:"name,omitempty" bson:"name,omitempty" msg:"name"`
	Order *int    `json:",omitempty" bson:",omitempty" msg:""`
}

func (o CategoryDiff) empty() bool {
	return o.Name == nil &&
		o.Order == nil
}

type EventDiff struct {
	Home   *string     `json:",omitempty" bson:",omitempty" msg:""`
	Away   *string     `json:",omitempty" bson:",omitempty" msg:""`
	Result *ResultDiff `json:"result,omitempty" bson:"result,omitempty" msg:"result"`
}

func (o EventDiff) empty() bool {
	return o.Home == nil &&
		o.Away == nil &&
		o.Result == nil
}

type ResultDiff struct {
	Home *int `json:"home,omitempty" bson:"home,omitempty" msg:"home"`
	Away *int `json:"away,omitempty" bson:"away,omitempty" msg:"away"`
}

func (o ResultDiff) empty() bool {
	return o.Home == nil &&
		o.Away == nil
}

type ItemDiff struct {
	Filed1 *string `json:"filed1,omitempty" bson:"filed1,omitempty" msg:"filed1"`
	Filed2 *int    `json:"filed2,omitempty" bson:"filed2,omitempty" msg:"filed2"`
}

func (o ItemDiff) empty() bool {
	return o.Filed1 == nil &&
		o.Filed2 == nil
}

// MergeDiff applies diff (d) to Book (o).
func (o Book) MergeDiff(d *BookDiff) (Book, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Version != nil && *d.Version != o.Version {
		o.Version = *d.Version
		changed = true
	}
	// Sports map
	var copySportsOnce sync.Once
	copyOnWriteSports := func() {
		copySportsOnce.Do(func() {
			m := make(map[string]Sport)
			for k, v := range o.Sports {
				m[k] = v
			}
			o.Sports = m
			changed = true
		})
	}
	for k, dc := range d.Sports {
		c, ok := o.Sports[k]
		if dc == nil {
			if ok {
				copyOnWriteSports()
				delete(o.Sports, k)
			}
			continue
		}
		if c2, merged := c.MergeDiff(dc); merged {
			copyOnWriteSports()
			o.Sports[k] = c2
		}
	}
	// Events map
	var copyEventsOnce sync.Once
	copyOnWriteEvents := func() {
		copyEventsOnce.Do(func() {
			m := make(map[string]Event)
			for k, v := range o.Events {
				m[k] = v
			}
			o.Events = m
			changed = true
		})
	}
	for k, dc := range d.Events {
		c, ok := o.Events[k]
		if dc == nil {
			if ok {
				copyOnWriteEvents()
				delete(o.Events, k)
			}
			continue
		}
		if c2, merged := c.MergeDiff(dc); merged {
			copyOnWriteEvents()
			o.Events[k] = c2
		}
	}
	// Items map
	var copyItemsOnce sync.Once
	copyOnWriteItems := func() {
		copyItemsOnce.Do(func() {
			m := make(map[string]Item)
			for k, v := range o.Items {
				m[k] = v
			}
			o.Items = m
			changed = true
		})
	}
	for k, dc := range d.Items {
		c, ok := o.Items[k]
		if dc == nil {
			if ok {
				copyOnWriteItems()
				delete(o.Items, k)
			}
			continue
		}
		if c2, merged := c.MergeDiff(dc); merged {
			copyOnWriteItems()
			o.Items[k] = c2
		}
	}
	return o, changed
}

// MergeDiff applies diff (d) to Sport (o).
func (o Sport) MergeDiff(d *SportDiff) (Sport, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	if d.Order != nil && *d.Order != o.Order {
		o.Order = *d.Order
		changed = true
	}
	// Categories map
	var copyCategoriesOnce sync.Once
	copyOnWriteCategories := func() {
		copyCategoriesOnce.Do(func() {
			m := make(map[string]Category)
			for k, v := range o.Categories {
				m[k] = v
			}
			o.Categories = m
			changed = true
		})
	}
	for k, dc := range d.Categories {
		c, ok := o.Categories[k]
		if dc == nil {
			if ok {
				copyOnWriteCategories()
				delete(o.Categories, k)
			}
			continue
		}
		if c2, merged := c.MergeDiff(dc); merged {
			copyOnWriteCategories()
			o.Categories[k] = c2
		}
	}
	return o, changed
}

// MergeDiff applies diff (d) to Category (o).
func (o Category) MergeDiff(d *CategoryDiff) (Category, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	if d.Order != nil && *d.Order != o.Order {
		o.Order = *d.Order
		changed = true
	}
	return o, changed
}

// MergeDiff applies diff (d) to Event (o).
func (o Event) MergeDiff(d *EventDiff) (Event, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Home != nil && *d.Home != o.Home {
		o.Home = *d.Home
		changed = true
	}
	if d.Away != nil && *d.Away != o.Away {
		o.Away = *d.Away
		changed = true
	}
	// Result field
	if o2, merged := o.Result.MergeDiff(d.Result); merged {
		o.Result = o2
		changed = true
	}
	return o, changed
}

// MergeDiff applies diff (d) to Result (o).
func (o Result) MergeDiff(d *ResultDiff) (Result, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Home != nil && *d.Home != o.Home {
		o.Home = *d.Home
		changed = true
	}
	if d.Away != nil && *d.Away != o.Away {
		o.Away = *d.Away
		changed = true
	}
	return o, changed
}

// MergeDiff applies diff (d) to Item (o).
func (o Item) MergeDiff(d *ItemDiff) (Item, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Filed1 != nil && *d.Filed1 != o.Filed1 {
		o.Filed1 = *d.Filed1
		changed = true
	}
	if d.Filed2 != nil && *d.Filed2 != o.Filed2 {
		o.Filed2 = *d.Filed2
		changed = true
	}
	return o, changed
}

// Diff creates diff (i) between new (n) and old (o) Book.
// So that diff applyed to old will produce new.
func (o Book) Diff(n Book) *BookDiff {
	i := &BookDiff{}
	if n.Version != o.Version {
		i.Version = &n.Version
	}
	i.Sports = make(map[string]*SportDiff)
	for k, nc := range n.Sports {
		oc, ok := o.Sports[k]
		if !ok {
			oc = Sport{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Sports[k] = ip
		}
	}

	for k, _ := range o.Sports {
		if _, ok := n.Sports[k]; !ok {
			i.Sports[k] = nil
		}
	}

	if len(i.Sports) == 0 {
		i.Sports = nil
	}
	i.Events = make(map[string]*EventDiff)
	for k, nc := range n.Events {
		oc, ok := o.Events[k]
		if !ok {
			oc = Event{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Events[k] = ip
		}
	}

	for k, _ := range o.Events {
		if _, ok := n.Events[k]; !ok {
			i.Events[k] = nil
		}
	}

	if len(i.Events) == 0 {
		i.Events = nil
	}
	i.Items = make(map[string]*ItemDiff)
	for k, nc := range n.Items {
		oc, ok := o.Items[k]
		if !ok {
			oc = Item{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Items[k] = ip
		}
	}

	for k, _ := range o.Items {
		if _, ok := n.Items[k]; !ok {
			i.Items[k] = nil
		}
	}

	if len(i.Items) == 0 {
		i.Items = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Sport.
// So that diff applyed to old will produce new.
func (o Sport) Diff(n Sport) *SportDiff {
	i := &SportDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	if n.Order != o.Order {
		i.Order = &n.Order
	}
	i.Categories = make(map[string]*CategoryDiff)
	for k, nc := range n.Categories {
		oc, ok := o.Categories[k]
		if !ok {
			oc = Category{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Categories[k] = ip
		}
	}

	for k, _ := range o.Categories {
		if _, ok := n.Categories[k]; !ok {
			i.Categories[k] = nil
		}
	}

	if len(i.Categories) == 0 {
		i.Categories = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Category.
// So that diff applyed to old will produce new.
func (o Category) Diff(n Category) *CategoryDiff {
	i := &CategoryDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	if n.Order != o.Order {
		i.Order = &n.Order
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Event.
// So that diff applyed to old will produce new.
func (o Event) Diff(n Event) *EventDiff {
	i := &EventDiff{}
	if n.Home != o.Home {
		i.Home = &n.Home
	}
	if n.Away != o.Away {
		i.Away = &n.Away
	}
	i.Result = o.Result.Diff(n.Result)
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Result.
// So that diff applyed to old will produce new.
func (o Result) Diff(n Result) *ResultDiff {
	i := &ResultDiff{}
	if n.Home != o.Home {
		i.Home = &n.Home
	}
	if n.Away != o.Away {
		i.Away = &n.Away
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Item.
// So that diff applyed to old will produce new.
func (o Item) Diff(n Item) *ItemDiff {
	i := &ItemDiff{}
	if n.Filed1 != o.Filed1 {
		i.Filed1 = &n.Filed1
	}
	if n.Filed2 != o.Filed2 {
		i.Filed2 = &n.Filed2
	}
	if i.empty() {
		return nil
	}
	return i
}
