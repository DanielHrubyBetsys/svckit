// Code generated by go generate; DO NOT EDIT.
package diff

import "sync"

type BookDiff struct {
	Version *int                  `json:"version,omitempty" bson:"version,omitempty" msg:"version"`
	Sports  map[string]*SportDiff `json:"sports,omitempty" bson:"sports,omitempty" msg:"sports"`
}

func (o BookDiff) empty() bool {
	return o.Version == nil &&
		(o.Sports == nil || len(o.Sports) == 0)
}

type SportDiff struct {
	Name       *string                  `json:"name,omitempty" bson:"name,omitempty" msg:"name"`
	Categories map[string]*CategoryDiff `json:"categories,omitempty" bson:"categories,omitempty" msg:"categories"`
}

func (o SportDiff) empty() bool {
	return o.Name == nil &&
		(o.Categories == nil || len(o.Categories) == 0)
}

type CategoryDiff struct {
	Name *string `json:"name,omitempty" bson:"name,omitempty" msg:"name"`
}

func (o CategoryDiff) empty() bool {
	return o.Name == nil
}

// MergeDiff applies diff (d) to Book (o).
func (o Book) MergeDiff(d *BookDiff) (bool, Book) {
	if d == nil {
		return false, o
	}
	changed := false
	if d.Version != nil && *d.Version != o.Version {
		o.Version = *d.Version
		changed = true
	}

	var copySportsOnce sync.Once
	copyOnWriteSports := func() {
		copySportsOnce.Do(func() {
			m := make(map[string]Sport)
			for k, v := range o.Sports {
				m[k] = v
			}
			o.Sports = m
			changed = true
		})
	}

	for k, dc := range d.Sports {
		c, ok := o.Sports[k]
		if dc == nil {
			if ok {
				copyOnWriteSports()
				delete(o.Sports, k)
			}
			continue
		}
		merged, c := c.MergeDiff(dc)
		if !merged {
			continue
		}
		copyOnWriteSports()
		o.Sports[k] = c
	}
	return changed, o
}

// MergeDiff applies diff (d) to Sport (o).
func (o Sport) MergeDiff(d *SportDiff) (bool, Sport) {
	if d == nil {
		return false, o
	}
	changed := false
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	for k, dc := range d.Categories {
		c, ok := o.Categories[k]
		if dc == nil {
			if ok {
				delete(o.Categories, k)
				changed = true
			}
			continue
		}
		if !ok {
			if o.Categories == nil {
				o.Categories = make(map[string]Category)
			}
		}
		merged, c := c.MergeDiff(dc)
		if !merged {
			continue
		}
		o.Categories[k] = c
		changed = true
	}
	return changed, o
}

// MergeDiff applies diff (d) to Category (o).
func (o Category) MergeDiff(d *CategoryDiff) (bool, Category) {
	if d == nil {
		return false, o
	}
	changed := false
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	return changed, o
}

// Diff creates diff (i) between new (n) and old (o) Book.
// So that diff applyed to old will produce new.
func (o Book) Diff(n Book) *BookDiff {
	i := &BookDiff{}
	if n.Version != o.Version {
		i.Version = &n.Version
	}
	i.Sports = make(map[string]*SportDiff)
	for k, nc := range n.Sports {
		oc, ok := o.Sports[k]
		if !ok {
			oc = Sport{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Sports[k] = ip
		}
	}
	for k, _ := range o.Sports {
		if _, ok := n.Sports[k]; !ok {
			i.Sports[k] = nil // signal delete
		}
	}
	if len(i.Sports) == 0 {
		i.Sports = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Sport.
// So that diff applyed to old will produce new.
func (o Sport) Diff(n Sport) *SportDiff {
	i := &SportDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	i.Categories = make(map[string]*CategoryDiff)
	for k, nc := range n.Categories {
		oc, ok := o.Categories[k]
		if !ok {
			oc = Category{}
		}
		ip := oc.Diff(nc)
		if ip != nil {
			i.Categories[k] = ip
		}
	}
	for k, _ := range o.Categories {
		if _, ok := n.Categories[k]; !ok {
			i.Categories[k] = nil // signal delete
		}
	}
	if len(i.Categories) == 0 {
		i.Categories = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

// Diff creates diff (i) between new (n) and old (o) Category.
// So that diff applyed to old will produce new.
func (o Category) Diff(n Category) *CategoryDiff {
	i := &CategoryDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	if i.empty() {
		return nil
	}
	return i
}
