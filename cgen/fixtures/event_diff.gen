// Code generated by go generate; DO NOT EDIT.
package cgen_test

import (
	"sync"
	"time"
)

type EventDiff struct {
	Home     *string       `json:"h,omitempty"`
	Away     *string       `json:"a,omitempty"`
	Schedule *time.Time    `json:"s,omitempty"`
	Result   *ResultDiff   `json:"r,omitempty"`
	Markets  MarketDiffMap `json:"m,omitempty"`
}

type MarketDiffMap map[int]*MarketDiff

func (m *MarketDiffMap) Set(key int, value *MarketDiff) *MarketDiff {
	if *m == nil {
		*m = make(map[int]*MarketDiff)
	}
	mv := *m
	mv[key] = value
	return value
}
func (m *MarketDiffMap) Nil(key int) {
	m.Set(key, nil)
}
func (m *MarketDiffMap) Empty(key int) *MarketDiff {
	return m.Set(key, &MarketDiff{})
}

type MarketDiff struct {
	Name     *string        `json:"name,omitempty"`
	Outcomes OutcomeDiffMap `json:"outcomes,omitempty"`
}

type OutcomeDiffMap map[int]*OutcomeDiff

func (m *OutcomeDiffMap) Set(key int, value *OutcomeDiff) *OutcomeDiff {
	if *m == nil {
		*m = make(map[int]*OutcomeDiff)
	}
	mv := *m
	mv[key] = value
	return value
}
func (m *OutcomeDiffMap) Nil(key int) {
	m.Set(key, nil)
}
func (m *OutcomeDiffMap) Empty(key int) *OutcomeDiff {
	return m.Set(key, &OutcomeDiff{})
}

type OutcomeDiff struct {
	Name *string  `json:"name,omitempty"`
	Odds *float64 `json:"odds,omitempty"`
}

type ResultDiff struct {
	Home *int `json:"home,omitempty"`
	Away *int `json:"away,omitempty"`
}

// Merge applies diff (d) to Event (o)
// and returns new value type with merged changes.
// Doesn't modifies original value (o).
func (o Event) Merge(d EventDiff) Event {
	n, _ := o.merge(&d)
	return n
}

func (o Event) merge(d *EventDiff) (Event, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Home != nil && *d.Home != o.Home {
		o.Home = *d.Home
		changed = true
	}
	if d.Away != nil && *d.Away != o.Away {
		o.Away = *d.Away
		changed = true
	}
	if d.Schedule != nil && *d.Schedule != o.Schedule {
		o.Schedule = *d.Schedule
		changed = true
	}
	// Result field
	if o2, merged := o.Result.merge(d.Result); merged {
		o.Result = o2
		changed = true
	}
	// Markets map
	var copyMarketsOnce sync.Once
	copyOnWriteMarkets := func() {
		copyMarketsOnce.Do(func() {
			m := make(map[int]Market)
			for k, v := range o.Markets {
				m[k] = v
			}
			o.Markets = m
			changed = true
		})
	}
	for k, dc := range d.Markets {
		c, ok := o.Markets[k]
		if dc == nil {
			if ok {
				copyOnWriteMarkets()
				delete(o.Markets, k)
			}
			continue
		}
		if c2, merged := c.merge(dc); merged {
			copyOnWriteMarkets()
			o.Markets[k] = c2
		}
	}
	return o, changed
}

func (o Market) merge(d *MarketDiff) (Market, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	// Outcomes map
	var copyOutcomesOnce sync.Once
	copyOnWriteOutcomes := func() {
		copyOutcomesOnce.Do(func() {
			m := make(map[int]Outcome)
			for k, v := range o.Outcomes {
				m[k] = v
			}
			o.Outcomes = m
			changed = true
		})
	}
	for k, dc := range d.Outcomes {
		c, ok := o.Outcomes[k]
		if dc == nil {
			if ok {
				copyOnWriteOutcomes()
				delete(o.Outcomes, k)
			}
			continue
		}
		if c2, merged := c.merge(dc); merged {
			copyOnWriteOutcomes()
			o.Outcomes[k] = c2
		}
	}
	return o, changed
}

func (o Outcome) merge(d *OutcomeDiff) (Outcome, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Name != nil && *d.Name != o.Name {
		o.Name = *d.Name
		changed = true
	}
	if d.Odds != nil && *d.Odds != o.Odds {
		o.Odds = *d.Odds
		changed = true
	}
	return o, changed
}

func (o Result) merge(d *ResultDiff) (Result, bool) {
	if d == nil {
		return o, false
	}
	changed := false
	// fields
	if d.Home != nil && *d.Home != o.Home {
		o.Home = *d.Home
		changed = true
	}
	if d.Away != nil && *d.Away != o.Away {
		o.Away = *d.Away
		changed = true
	}
	return o, changed
}

// Diff creates diff (i) between new (n) and old (o) Event.
// So that diff applyed to old will produce new.
func (o Event) Diff(n Event) *EventDiff {
	return o.diff(n)
}

func (o Event) diff(n Event) *EventDiff {
	i := &EventDiff{}
	if n.Home != o.Home {
		i.Home = &n.Home
	}
	if n.Away != o.Away {
		i.Away = &n.Away
	}
	if n.Schedule != o.Schedule {
		i.Schedule = &n.Schedule
	}
	i.Result = o.Result.diff(n.Result)
	i.Markets = make(map[int]*MarketDiff)
	for k, nc := range n.Markets {
		oc, ok := o.Markets[k]
		if !ok {
			oc = Market{}
		}
		ip := oc.diff(nc)
		if ip != nil {
			i.Markets[k] = ip
		}
	}

	for k, _ := range o.Markets {
		if _, ok := n.Markets[k]; !ok {
			i.Markets[k] = nil
		}
	}

	if len(i.Markets) == 0 {
		i.Markets = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

func (i EventDiff) empty() bool {
	return i.Home == nil &&
		i.Away == nil &&
		i.Schedule == nil &&
		i.Result == nil &&
		(i.Markets == nil || len(i.Markets) == 0)
}

func (o Market) diff(n Market) *MarketDiff {
	i := &MarketDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	i.Outcomes = make(map[int]*OutcomeDiff)
	for k, nc := range n.Outcomes {
		oc, ok := o.Outcomes[k]
		if !ok {
			oc = Outcome{}
		}
		ip := oc.diff(nc)
		if ip != nil {
			i.Outcomes[k] = ip
		}
	}

	for k, _ := range o.Outcomes {
		if _, ok := n.Outcomes[k]; !ok {
			i.Outcomes[k] = nil
		}
	}

	if len(i.Outcomes) == 0 {
		i.Outcomes = nil
	}
	if i.empty() {
		return nil
	}
	return i
}

func (i MarketDiff) empty() bool {
	return i.Name == nil &&
		(i.Outcomes == nil || len(i.Outcomes) == 0)
}

func (o Outcome) diff(n Outcome) *OutcomeDiff {
	i := &OutcomeDiff{}
	if n.Name != o.Name {
		i.Name = &n.Name
	}
	if n.Odds != o.Odds {
		i.Odds = &n.Odds
	}
	if i.empty() {
		return nil
	}
	return i
}

func (i OutcomeDiff) empty() bool {
	return i.Name == nil &&
		i.Odds == nil
}

func (o Result) diff(n Result) *ResultDiff {
	i := &ResultDiff{}
	if n.Home != o.Home {
		i.Home = &n.Home
	}
	if n.Away != o.Away {
		i.Away = &n.Away
	}
	if i.empty() {
		return nil
	}
	return i
}

func (i ResultDiff) empty() bool {
	return i.Home == nil &&
		i.Away == nil
}

func (o Event) Copy() Event {
	copyMarkets := make(map[int]Market)
	for k, v := range o.Markets {
		copyMarkets[k] = v.Copy()
	}
	o.Markets = copyMarkets
	return o
}

func (o Market) Copy() Market {
	copyOutcomes := make(map[int]Outcome)
	for k, v := range o.Outcomes {
		copyOutcomes[k] = v.Copy()
	}
	o.Outcomes = copyOutcomes
	return o
}

func (o Outcome) Copy() Outcome {
	return o
}

func (o Result) Copy() Result {
	return o
}
